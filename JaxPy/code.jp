procedure func1 (a: number, b: string): number {
  return 2;
}
#let a:string = "hello";
#let a:number = 2;
#let a: number = "hello\nworld";
?
let a: number = "hello\nworld";
\nt
?

class C1 {
  method m2(a: string): void {return;}
}

let a: number = 4 / 7 - 3;

interface E {
    method GetArea(): void;
}

interface B {
    method GetArea(c: string): number;
}

class Car implements E {
  wheel: number;
  method m1(): number {
    if (1==2) {
      const a: number = 2;
    } else {
      #return c;
    }
  }
  method GetArea(): void {}
}
 
let a: number = func1(1, "abc", 3);


procedure func2(a: number): number {
  let b: number[];
  return a;
}

let newCar: Car;
#let a: number = z;

procedure func3(): void {
  let a: number[][];
}

#let 7b: string = "a" + "b";
#constant d: string = "abcdefghi";
const d: string = "abcdefghi";

procedure func4(): number {
    const a: number = 4;
}

until (1==2) {
  continue;
  break;
}

until (func4() != 2) {

}

procedure new_func(): Car {
  let car: Car;
  return car;
}

func2(a);

let z:number = 3;
if (z > a) {  
  #z return;
}

class Wheel {
  
}

let car1: Car = new Car(a);
procedure func5 (): number {

}

let n1: number = func5();

until (1==2) {
  if(2 == 2){
    continue;
  }else{
    break;
  }
}
